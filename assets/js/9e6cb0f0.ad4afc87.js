"use strict";(globalThis.webpackChunkmi_sitio=globalThis.webpackChunkmi_sitio||[]).push([[480],{7110(e,s,r){r.d(s,{A:()=>n});const n=r.p+"assets/images/24-896011d0b28bf82ffc28e6a5c4b25290.png"},7188(e,s,r){r.d(s,{A:()=>n});const n=r.p+"assets/images/26-eb41331f391d599fce8dcd404cee2862.png"},8317(e,s,r){r.d(s,{A:()=>n});const n=r.p+"assets/images/27-946f589bea64e64b4be39628cd9e29bb.png"},8453(e,s,r){r.d(s,{R:()=>d,x:()=>o});var n=r(6540);const t={},i=n.createContext(t);function d(e){const s=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),n.createElement(i.Provider,{value:s},e.children)}},8655(e,s,r){r.d(s,{A:()=>n});const n=r.p+"assets/images/25-858ce4fdadc7992830b2195df42f80ef.png"},9037(e,s,r){r.r(s),r.d(s,{assets:()=>a,contentTitle:()=>o,default:()=>l,frontMatter:()=>d,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"editor/shaders","title":"Shaders","description":"Shader integration in Brakeza3D including GLSL shaders, node-based visual shaders, and postprocessing effects.","source":"@site/docs/2-editor/6-shaders.md","sourceDirName":"2-editor","slug":"/editor/shaders","permalink":"/docs/editor/shaders","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Shaders","description":"Shader integration in Brakeza3D including GLSL shaders, node-based visual shaders, and postprocessing effects."},"sidebar":"tutorialSidebar","previous":{"title":"Scripts","permalink":"/docs/editor/scripts"},"next":{"title":"Shader Node Editor","permalink":"/docs/editor/node-editor"}}');var t=r(4848),i=r(8453);const d={title:"Shaders",description:"Shader integration in Brakeza3D including GLSL shaders, node-based visual shaders, and postprocessing effects."},o="Shaders",a={},c=[{value:"Shader Integration",id:"shader-integration",level:2},{value:"Types of Shaders",id:"types-of-shaders",level:2},{value:"PostProcessing Shaders",id:"postprocessing-shaders",level:3},{value:"Object Shaders",id:"object-shaders",level:3},{value:"Mesh (Geometry) Shaders",id:"mesh-geometry-shaders",level:4},{value:"PostProcessing Object Shaders",id:"postprocessing-object-shaders",level:4},{value:"Node-Based Shaders",id:"node-based-shaders",level:2},{value:"PostProcessing Shader Nodes",id:"postprocessing-shader-nodes",level:3},{value:"Object Shader Nodes",id:"object-shader-nodes",level:3},{value:"Managing Shaders",id:"managing-shaders",level:2},{value:"Nodes editor",id:"nodes-editor",level:2},{value:"Code editor",id:"code-editor",level:2},{value:"Selected object shaders widget",id:"selected-object-shaders-widget",level:2},{value:"Project shaders settings widget",id:"project-shaders-settings-widget",level:2}];function h(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",img:"img",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"shaders",children:"Shaders"})}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h2,{id:"shader-integration",children:"Shader Integration"}),"\n",(0,t.jsxs)(s.p,{children:["Shader integration is a core feature of ",(0,t.jsx)(s.strong,{children:"Brakeza3D"}),", allowing developers to create stunning visual effects and customize rendering at every level. Just like scripts, shaders can be assigned either to the entire scene or to individual objects, giving you full control over how your project looks and feels."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Brakeza3D"})," allows you to incorporate your own ",(0,t.jsx)(s.strong,{children:"GLSL shaders"}),", which can be written directly in code for maximum flexibility or created through a ",(0,t.jsx)(s.strong,{children:"node-based visual interface"})," for a more intuitive workflow. This makes the system accessible to both programmers and artists."]}),"\n",(0,t.jsxs)(s.p,{children:["The engine provides built-in tools in the GUI to edit and manage shaders. When creating a shader from the UI, Brakeza3D automatically generates a ",(0,t.jsx)(s.strong,{children:".vs (vertex shader)"})," and ",(0,t.jsx)(s.strong,{children:".fs (fragment shader)"})," file, along with a ",(0,t.jsx)(s.strong,{children:"JSON metadata file"})," that stores shader information. All shader parameters (uniforms) are exposed and can be modified at runtime, making it easy to fine-tune lighting and visual appearance dynamically."]}),"\n",(0,t.jsxs)(s.p,{children:["For advanced users, ",(0,t.jsx)(s.strong,{children:"Brakeza3D"})," supports shaders that directly modify ",(0,t.jsx)(s.strong,{children:"Mesh3D geometry"}),", enabling procedural effects, custom vertex manipulation, and advanced rendering techniques. This flexibility allows you to push beyond standard rendering and achieve unique visual results tailored to your project."]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h2,{id:"types-of-shaders",children:"Types of Shaders"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Brakeza3D"})," supports multiple shader types to cover different use cases:"]}),"\n",(0,t.jsx)(s.h3,{id:"postprocessing-shaders",children:"PostProcessing Shaders"}),"\n",(0,t.jsxs)(s.p,{children:["These shaders are applied after the scene is rendered and affect the ",(0,t.jsx)(s.strong,{children:"final image globally"}),". They are ideal for effects such as bloom, color grading, depth of field, fog, motion blur, and other cinematic enhancements. Postprocessing shaders can only be applied at the scene level and modify all objects at once, giving your projects a polished, professional look."]}),"\n",(0,t.jsx)(s.h3,{id:"object-shaders",children:"Object Shaders"}),"\n",(0,t.jsxs)(s.p,{children:["Object shaders are applied to ",(0,t.jsx)(s.strong,{children:"individual Mesh3D objects"})," and control how they interact with light and how their surfaces appear. They are divided into two categories:"]}),"\n",(0,t.jsx)(s.h4,{id:"mesh-geometry-shaders",children:"Mesh (Geometry) Shaders"}),"\n",(0,t.jsx)(s.p,{children:"These shaders operate on vertices and geometry before rasterization. They allow procedural geometry effects, vertex animation, and custom transformations. They control material properties such as color, texture, reflectivity, transparency, and more."}),"\n",(0,t.jsx)(s.h4,{id:"postprocessing-object-shaders",children:"PostProcessing Object Shaders"}),"\n",(0,t.jsxs)(s.p,{children:["These behave like postprocessing effects but are applied ",(0,t.jsx)(s.strong,{children:"locally to a specific object"}),", allowing effects such as glow, blur, or distortion on a single mesh instead of the whole scene."]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h2,{id:"node-based-shaders",children:"Node-Based Shaders"}),"\n",(0,t.jsxs)(s.p,{children:["Brakeza3D also supports ",(0,t.jsx)(s.strong,{children:"node-based shaders"}),", offering a visual alternative to GLSL coding:"]}),"\n",(0,t.jsx)(s.h3,{id:"postprocessing-shader-nodes",children:"PostProcessing Shader Nodes"}),"\n",(0,t.jsx)(s.p,{children:"Provide the same functionality as GLSL postprocessing shaders but through a visual node system. Artists can build effects like blur, color correction, and masking without writing code."}),"\n",(0,t.jsx)(s.h3,{id:"object-shader-nodes",children:"Object Shader Nodes"}),"\n",(0,t.jsx)(s.p,{children:"Work similarly to Object GLSL shaders but use nodes instead of code. They are ideal for visually modifying geometry, applying procedural effects, and customizing vertex attributes per object."}),"\n",(0,t.jsx)(s.h2,{id:"managing-shaders",children:"Managing Shaders"}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsxs)(s.p,{children:["Shaders are managed through the ",(0,t.jsx)(s.strong,{children:"File Browser"})," window (",(0,t.jsx)(s.strong,{children:"Window"})," \u2192 ",(0,t.jsx)(s.strong,{children:"File Browser"}),"). Navigate to the ",(0,t.jsx)(s.strong,{children:"Shaders"})," section to browse, create, edit, or delete shaders."]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{alt:"Shaders in File Browser",src:r(9529).A+"",width:"441",height:"379"})}),"\n",(0,t.jsx)(s.p,{children:"From the File Browser you can:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Create"})," new shader files (GLSL or Node-based)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Open"})," shaders in the Code Editor or Node Editor"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Delete"})," existing shaders"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Drag and drop"})," shaders to objects or project setup"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Brakeza3D"})," includes a wide variety of built-in post-processing shaders, which you can use freely in your projects."]}),"\n",(0,t.jsx)(s.h2,{id:"nodes-editor",children:"Nodes editor"}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsxs)(s.p,{children:["A ",(0,t.jsx)(s.code,{children:"Node Editor"})," in post-processing shaders provides a ",(0,t.jsx)(s.strong,{children:"visual"}),", ",(0,t.jsx)(s.strong,{children:"modular way"})," to create and customize effects. ",(0,t.jsx)(s.strong,{children:"Instead of writing code"}),", you can connect nodes representing operations, textures, and mathematical functions, allowing you to design complex visual effects like color adjustments,\r\nblurs, distortions, and glow in an intuitive, flexible manner."]}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Nodes editor example #01"}),(0,t.jsx)(s.th,{children:"Nodes editor example #02"})]})}),(0,t.jsx)(s.tbody,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.img,{alt:"Nodes editor",src:r(7110).A+"",width:"906",height:"651"})}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.img,{alt:"Nodes editor nodes",src:r(8655).A+"",width:"906",height:"649"})})]})})]}),"\n",(0,t.jsx)(s.h2,{id:"code-editor",children:"Code editor"}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsxs)(s.p,{children:["Like scripts, shaders that don\u2019t use nodes ",(0,t.jsx)(s.strong,{children:"can be written from scratch"}),". ",(0,t.jsx)(s.strong,{children:"Brakeza3D"})," uses ",(0,t.jsx)(s.code,{children:"GLSL"})," language, and the ",(0,t.jsx)(s.code,{children:"Code Editor"})," lets you edit both ",(0,t.jsx)(s.code,{children:"vertex"})," and ",(0,t.jsx)(s.code,{children:"fragment"})," shaders."]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{alt:"Shaders browser",src:r(7188).A+"",width:"1176",height:"647"})}),"\n",(0,t.jsxs)(s.p,{children:["In addition to the code, you can also modify the ",(0,t.jsx)(s.strong,{children:"default values of variables"})," (called uniforms in GLSL)."]}),"\n",(0,t.jsx)(s.h2,{id:"selected-object-shaders-widget",children:"Selected object shaders widget"}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"Object Shaders"})," window lets you manage shaders ",(0,t.jsx)(s.strong,{children:"assigned to a specific object"}),". Clicking an object in the scene will display its shaders here, allowing you to configure them for that object only."]}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.img,{alt:"Object scripts",src:r(8317).A+"",width:"979",height:"384"})}),"\n",(0,t.jsx)(s.p,{children:"You can enable or disable each shader individually if desired."}),"\n",(0,t.jsx)(s.h2,{id:"project-shaders-settings-widget",children:"Project shaders settings widget"}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsxs)(s.p,{children:["As seen in section ",(0,t.jsx)(s.a,{href:"./projects#project-settings-window",children:"2.3) Projects"}),", each project has its own ",(0,t.jsx)(s.code,{children:"Project Setup"})," window, where associated shaders can be managed. From here, you can adjust shader settings."]})]})}function l(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},9529(e,s,r){r.d(s,{A:()=>n});const n=r.p+"assets/images/23-30a7be909b681c3ce3adb2cde510fc65.png"}}]);