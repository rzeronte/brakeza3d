"use strict";(globalThis.webpackChunkmi_sitio=globalThis.webpackChunkmi_sitio||[]).push([[7225],{524(e,i,n){n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"scripting-api/grid-and-octree","title":"Grid and Octree","description":"Grid3D and Octree data structures in Brakeza3D for spatial partitioning and A* pathfinding.","source":"@site/docs/4-scripting-api/12-grid-and-octree.md","sourceDirName":"4-scripting-api","slug":"/scripting-api/grid-and-octree","permalink":"/docs/scripting-api/grid-and-octree","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":13,"frontMatter":{"sidebar_position":13,"title":"Grid and Octree","description":"Grid3D and Octree data structures in Brakeza3D for spatial partitioning and A* pathfinding."},"sidebar":"tutorialSidebar","previous":{"title":"Shaders system","permalink":"/docs/scripting-api/shaders-system"},"next":{"title":"Components","permalink":"/docs/scripting-api/components"}}');var r=n(4848),s=n(8453);const a={sidebar_position:13,title:"Grid and Octree",description:"Grid3D and Octree data structures in Brakeza3D for spatial partitioning and A* pathfinding."},d="Grid3D and Octree",c={},o=[{value:"Filling Geometry in Grid3D",id:"filling-geometry-in-grid3d",level:2},{value:"Pathfinding in Grid3D",id:"pathfinding-in-grid3d",level:2},{value:"Click Object Detection",id:"click-object-detection",level:2},{value:"Basic Click Detection Example",id:"basic-click-detection-example",level:3},{value:"Method Reference",id:"method-reference",level:3}];function l(e){const i={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"grid3d-and-octree",children:"Grid3D and Octree"})}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Brakeza3D"})," includes Grid3D and Octree data structures integrated into Mesh3D objects."]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"Grid3D"}),": Creates a grid of X, Y, Z dimensions over the AABB of the given object."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"Octree"}),": Creates an octree with the specified depth (maxDepth)."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"To create a grid in a Mesh3D object, use BuildGrid3D(sizeX, sizeY, sizeZ):"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-lua",children:'eye = ObjectFactory.Mesh3D(\n    "../assets/models/Capsule.fbx",\n    Vertex3D.new(x, y, z)\n)\neye:BuildGrid3D(5, 5, 5)                                                    -- creates a 5x5x5 grid\n'})}),"\n",(0,r.jsxs)(i.p,{children:["To create an octree use ",(0,r.jsx)(i.code,{children:"BuildOctree(int maxDepth)"}),":"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-lua",children:'eye = ObjectFactory.Mesh3D("../assets/models/Capsule.fbx", Vertex3D.new(x, y, z))\neye:BuildOctree(1) -- creates an octree with a single depth level, only 8 children\n'})}),"\n",(0,r.jsxs)(i.p,{children:["To readjust the dimensions of both grids and octree structures, simply rerun ",(0,r.jsx)(i.code,{children:"buildGrid3D()"})," or ",(0,r.jsx)(i.code,{children:"buildOctree()"}),"."]}),"\n",(0,r.jsx)(i.h2,{id:"filling-geometry-in-grid3d",children:"Filling Geometry in Grid3D"}),"\n",(0,r.jsx)(i.p,{children:"Grid3D stores a boolean flag for each cell. Brakeza3D provides a method fillGrid3DFromGeometry, which\nsets this flag for each cell if no triangle intersects or is contained in it:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-lua",children:'eye = ObjectFactory.Mesh3D("../assets/models/Capsule.fbx", Vertex3D.new(x, y, z))\neye:BuildGrid3D(5, 5, 5)\neye:FillGrid3DFromGeometry()                -- sets flags for empty cells\n'})}),"\n",(0,r.jsx)(i.p,{children:"This is especially useful for pathfinding techniques."}),"\n",(0,r.jsx)(i.h2,{id:"pathfinding-in-grid3d",children:"Pathfinding in Grid3D"}),"\n",(0,r.jsx)(i.p,{children:"Grids include an A* algorithm that allows iterating over their cells. Combined with fillGrid3DFromGeometry,\npaths can avoid cells with geometry:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-lua",children:'eye = ObjectFactory.Mesh3D("../assets/models/Capsule.fbx", Vertex3D.new(x, y, z))\neye:BuildGrid3D(5, 5, 5)\neye:FillGrid3DFromGeometry()                    -- fill with geometry\n\neye:getGrid3D():setTravel(0, 0, 0, 5, 5, 5)     -- set travel from (0,0,0) to (5,5,5)\npath = eye:getGrid3D():MakeTravelCubesGrid()    -- returns an array of CubeGrid3D\n'})}),"\n",(0,r.jsxs)(i.p,{children:["Using the method ",(0,r.jsx)(i.code,{children:"setTravel(x1, y1, z1, x2, y2, z2)"}),", you can define the start and end points for the next path request made through ",(0,r.jsx)(i.code,{children:"MakeTravelCubesGrid()"}),"."]}),"\n",(0,r.jsx)(i.p,{children:"The method MakeTravelCubesGrid returns the requested path as an array of CubeGrid3D structures:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-cpp",children:"struct CubeGrid3D {\n    AABB3D box;             // bounding box\n    int posX;               // X index in the grid\n    int posY;               // Y index\n    int posZ;               // Z index\n    bool passed = true;     // Flag\n};\n"})}),"\n",(0,r.jsx)(i.p,{children:"You can iterate over this array to obtain the desired path:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-lua",children:'...\npath = eye:getGrid3D():MakeTravelCubesGrid()            -- we get a travel path\n\nfor i, cube in ipairs(path) do\n    print("Cube " .. i .. ": X = " .. cube.posX .. ", Y = " .. cube.posY .. ", Z = " .. cube.posZ)\nend\n...\n'})}),"\n",(0,r.jsx)(i.h2,{id:"click-object-detection",children:"Click Object Detection"}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Brakeza3D"})," provides native functionality for detecting clicks on ",(0,r.jsx)(i.code,{children:"Object3D"})," instances using raycasting."]}),"\n",(0,r.jsxs)(i.p,{children:["To detect if an object was clicked, you can use the ",(0,r.jsx)(i.code,{children:"isRayCollisionWith()"})," method from the Collisions component. This method casts a ray from one point to another and checks if it intersects with a specific object."]}),"\n",(0,r.jsx)(i.h3,{id:"basic-click-detection-example",children:"Basic Click Detection Example"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-lua",children:'function onUpdate()\n    local input = Components:Input()\n\n    if input:isClickLeft() then\n        -- Get mouse position relative to renderer\n        local mouseX = input:getRelativeRendererMouseX()\n        local mouseY = input:getRelativeRendererMouseY()\n\n        -- Get camera for ray origin\n        local camera = Components:Camera():getCamera()\n        local rayOrigin = camera:getPosition()\n\n        -- Calculate ray direction from camera through mouse position\n        -- (simplified - actual implementation depends on your projection)\n        local rayEnd = Vertex3D.new(mouseX, mouseY, 100)\n\n        -- Check collision with a specific object\n        local targetObject = Brakeza:getSceneObjectByLabel("MyObject")\n        if Components:Collisions():isRayCollisionWith(rayOrigin, rayEnd, targetObject) then\n            print("Object clicked!")\n        end\n    end\nend\n'})}),"\n",(0,r.jsx)(i.h3,{id:"method-reference",children:"Method Reference"}),"\n",(0,r.jsxs)(i.table,{children:[(0,r.jsx)(i.thead,{children:(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.th,{children:"Method"}),(0,r.jsx)(i.th,{children:"Parameters"}),(0,r.jsx)(i.th,{children:"Return"}),(0,r.jsx)(i.th,{children:"Description"})]})}),(0,r.jsx)(i.tbody,{children:(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"isRayCollisionWith()"})}),(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"from: Vertex3D, to: Vertex3D, object: Object3D"})}),(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"bool"})}),(0,r.jsxs)(i.td,{children:["Returns true if the ray from ",(0,r.jsx)(i.code,{children:"from"})," to ",(0,r.jsx)(i.code,{children:"to"})," intersects with the specified object"]})]})})]}),"\n",(0,r.jsx)(i.admonition,{type:"note",children:(0,r.jsx)(i.p,{children:"For click detection to work properly, the target object must have collisions enabled with an appropriate collider shape configured."})})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453(e,i,n){n.d(i,{R:()=>a,x:()=>d});var t=n(6540);const r={},s=t.createContext(r);function a(e){const i=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function d(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);