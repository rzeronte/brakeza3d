========================================================================================================

12 - SCRIPTING SYSTEM

========================================================================================================

Brakeza3D incorpora un sistema de scripting utilizando LUA como lenguaje.

Ya sea desde la UI o desde código, podrás asociar scripts al proyecto,
escena y/o objetos.

========================================================================================================

### 12.1) Estados del sistema de scripting

========================================================================================================

En el búcle principal de Brakeza3D, se ejecutan una serie de acciones constantemente. Una de ellas
es el sistema de scripting. Este sistema puede estar en ON/OFF/PAUSE.

Si está en ON, los objetos ejecutarán su ciclo de vida implementado en los scripts.

El sistema de scripting puede ser ejecutado (PLAY), para iniciar la ejecución de los scripts.

Finalmente, podrá ser detenido (STOP) para evitar que el sistema de scripting continue.

También podrás resetear (RELOAD) el estado para volver al inicio los scripts y para refrescarlos desde disco.

========================================================================================================

### 12.2) Ciclo de vida de un objeto

========================================================================================================

Los objetos disponen de su propio ciclo de vida el cual debemos de entender para trabajar con nuestros objetos cargados, es el siguiente:

- **onStart**: Instante en que se inicia la ejecución. Cuando activamos el sistema de scripting (PLAY)

- **onUpdate**: Instante actual, es decir, cada frame.

- **onEnd**: Instante en el que se detiene la ejecución (STOP)

Una template básica de script LUA para Brakeza3D sería:

    function onStart()
        -- código a ejecutar al inicio del sprint, una única vez.
    end

    function onUpdate()
        -- código a ejecutar en cada frame.
    end

========================================================================================================

### 12.3) Scripts LUA

========================================================================================================

Los scripts de LUA son elementos que podremos vincular a elementos del sistema. En ellos implementaremos la lógica y comportamiento de objetos en Brakeza3D.

Podemos diferenciar dos grandes tipos de scripts:

- **Scripts de Objeto**: Se asocian a **objetos**. Un mismo script puede vincularse a multitud de objetos.
- **Scripts globales**: Se asocian a la **escena** o al **proyecto**, no a ningún objeto específico, son de caracter general.

Se diferencian principalmente por el **scope de sus variables**.

Los scripts globales comparten variables libremente entre ellos, mientras que los scripts de objeto instancian sus variables por cada objeto al
que han sido vinculados.

========================================================================================================

### 12.4) Vinculación de scripts

========================================================================================================

Podrás realizar estas operaciones desde la UI con el ratón y drag/drop, sin embargo,
en ocasiones necesitarás poder hacerlo dinámicamente desde código.

Disponemos de un objeto ScriptLUA que encapsula la lógica de carga de un script.

Los Object3D disponen de un método attachScript que nos permitirá vincularlos:

    print("Load LightPoint3D")
    lightp = LightPoint3D.create(Vertex3D.new(5, -10, 5))
    brakeza:addObject3D(lightp, 'myLightPoint')

    script = ScriptLUA.create("../../scripts/MoveForwardObject.lua")
    if script ~= nil then
        lightp:attachScript(script)
    end

De igual forma el ComponentScripting dispone de addSceneLUAScript que te permitirá vincular
un script a la escena:

    script = ScriptLUA.create("../../scripts/global_script.lua")
    if script ~= nil then
        componentsManager:getComponentScripting():addSceneLUAScript(script)
    end

Es importante destacar, que *la única* forma de vincular scripts al proyecto es mediante la UI, no desde código.

========================================================================================================

### 12.5) Variables

========================================================================================================

Cualquier script LUA puede definir variables que te ayudarán a implementar tu lógica. Puedes utilizar la GUI
para gestionar con facilidad las variables de un script.

Físicamente, se almacenan en un fichero JSON del mismo nombre que el script.

json
{
	"name":	"global_script_example.lua",
	"types": [
        {
          "name": "var1",
          "type": "string",
          "value": "hello my friend!"
        },
        {
          "name": "var2",
          "type": "int",
          "value": 10
        },
        {
          "name": "var3",
          "type": "float",
          "value": 0.3
        },
        {
          "name": "var4",
          "type": "Vertex3D",
          "value": {
            "x": 0,
            "y": 2,
            "z": 0
          }
        }
    ]
}

Puedes utilizar los tipos int, float, string y Vertex3D.

========================================================================================================

### 12.6) Variables globales

========================================================================================================

Las variables definidas en scripts vinculadas a proyectos y/o escenas serán globales.

Podrás acceder directamente a las variables globales desde cualquier otro
script.

    function onUpdate()
        var1 = var1 .. "!" -- ejemplo de variable global
        print("Value of var1: " .. var1)
    end

========================================================================================================

### 12.7) Variables locales

========================================================================================================

Las variables definidas en scripts vinculadas a Object3D serán locales,
es decir, se instancian individualmente por cada objeto.

Puedes acceder a las variables locales de otro objeto mediante tus scripts LUA
de la siguiente forma:

    o = brakeza:getSceneObjectByLabel("MyObject")
    position = o:getLocalScriptVar("offset") -- obtenemos un vertex3D
    print("Read variable 'offset' from object: ".. o:getLabel())
    print("Value for 'offset': " .. position.x .. ", " .. position.y .. ", " .. position.z)

    print("Read variable 'count' from object: ".. o:getLabel())
    print("Value for 'count': " .. o:getLocalScriptVar("count")) -- obtenemos int


========================================================================================================

### 12.8) Gestión de escenas

========================================================================================================

Puedes cargar y salvar escenas tanto desde GUI como desde tus scripts LUA

    function onStart()
        ...
        componentsManager:getComponentRender():getSceneLoader():loadScene("../scenes/scene_example.json")
        ...
        componentsManager:getComponentRender():getSceneLoader():saveScene("../scenes/scene_example.json")
        ...
    end

========================================================================================================

### 12.9) Deltatime

========================================================================================================

Él DeltaTime es el tiempo que tarda en renderizarse un frame. Es una medida crucial en el desarrollo de juegos,
ya que permite que los movimientos y animaciones sean consistentes independientemente de la velocidad de renderización.

Puedes obtenerlo desde tus scripts LUAde la siguiente manera:

    ...
    print("DeltaTime: " .. brakeza:getDeltaTime()) -- delta en segundos
    print("DeltaTimeInMicro: " .. brakeza:getDeltaTimeMicro()) -- delta en microsegundos
    print("Execution Time: " .. brakeza:getExecutionTime()) -- tiempo total de ejecución
    ...
    function onUpdate()
        local speed = 5.0  -- unidades por segundo
        local movement = speed * brakeza:getDeltaTime()
        myObject:addToPosition(Vertex3D.new(movement, 0, 0))
    end

========================================================================================================

### 12.10) Terminar la ejecución

========================================================================================================

Si deseas terminar la aplicación desde código, puedes hacerlo de la siguiente forma:

    brakeza:finish()

=========================================
### 12.11) Autocargar proyectos o escenas
=========================================

Cuando desees empaquetar tu juego o aplicación, desearás que Brakeza3D carge y ejecute automáticamente los scripts
de algún proyecto en particular. Podrás indicar esto a Brakeza3D desde la línea de comandos:

    brakeza3d.exe -p MyProject.json o brakeza3d.exe --project MyProject.json

Con esto el proyecto será ejecutado automáticamente sin UI.

Nota: La ruta en la que será buscado el fichero de proyecto es relativa al directorio base de
proyectos: /assets/projects/.

========================================================================================================

### 12.12) Grid3D y Octree

========================================================================================================

Brakeza3D incorpora las estructuras de datos Grid3D y Octree integradas en los objetos de tipo
Mesh3D.

- Grid3D: Crea una rejilla de X, Y, Z dimensiones sobre el AABB del objeto dado.
- Octree: Crea un árbol octal, con la profundidad (maxDepth) indicada.

Para cargar una rejilla en un objeto Mesh3D puedes utilizar el método buildGrid3D(sizeX, sizeY, sizeZ)

    eye = Mesh3D.create(Vertex3D.new(0, 0, 10), "../assets/models/eye.fbx")
    eye:setScale(10)
    eye:buildGrid3D(5, 5, 5) -- crea una rejilla de 5x5x5
    brakeza:addObject3D(eye, 'modelo')


Para cargar una *octree* en un objeto Mesh3D puedes utilizar el método buildOctree(maxDepth).

    eye = Mesh3D.create(Vertex3D.new(0, 0, 10), "../assets/models/eye.fbx")
    eye:setScale(10)
    eye:buildOctree(1) -- crea una árbol de octanos de un solo nivel de profundidad, solo 8 hijos
    brakeza:addObject3D(eye, 'modelo')

Para volver a ajustar las dimensiones tanto en las rejillas como en los árboles de octanos, simplemente
vuelve a ejecutar buildGrid3D o buildOctree.

Llenado de geometría en Grid3D
==============================

Los Grid3D almacenan un *flag boolean* por cada *celda* que podremos usar a nuestro antojo.
No obstante, Brakeza3D incorpora un mecanismo de relleno de este *flag* llamado fillGrid3DFromGeometry,
el cual activará este flag en cada celda, si ningún triángulo atraviesa o está contenido por dicha celda.

    eye = Mesh3D.create(Vertex3D.new(0, 0, 10), "../assets/models/eye.fbx")
    eye:setScale(10)
    eye:buildGrid3D(5, 5, 5)
    eye:fillGrid3DFromGeometry() -- activa los flags para celdas sin geometría
    brakeza:addObject3D(eye, 'modelo')

Será especialmente útil para aplicar técnicas de pathfinding disponer de esta información precargada
en un Grid3D.

#### Pathfinding en Grid3D
==========================

Las rejillas incorporan un algoritmo A* que permite iterar sobre sus celdas. En combinación con fillGrid3DFromGeometry,
podrás conseguir que los caminos esquiven nodos con geometría.

    eye = Mesh3D.create(Vertex3D.new(0, 0, 10), "../assets/models/eye.fbx")
    eye:buildGrid3D(5, 5, 5)                    -- construimos un grid de 5x5x5
    eye:fillGrid3DFromGeometry()                -- Flags basados en si hay o no geometría en cada celda
    brakeza:addObject3D(eye, 'modelo')

    eye:getGrid3D():setTravel(0, 0, 0, 5, 5, 5) -- Configuramos un viaje desde (0, 0, 0) hasta (5, 5, 5)
    path = eye:getGrid3D():makeTravelCubesGrid() -- Obtenemos un array de CubeGrid3D

Mediante el método setTravel(x1, y1, z1, x2, y2, z2), podremos ajustar el viaje para el próximo camino
solicitado mediante makeTravelCubesGrid.

El método makeTravelCubesGrid devuelve ell camino solicitado si este fue posible mediante un array de CubeGrid3D,
cuya estructura es la siguiente:

    struct CubeGrid3D {
        AABB3D box;             // Caja contenedora
        int posX;               // Índice de la posición X en el grid
        int posY;               // Índice de la posición Y en el grid
        int posZ;               // Índice de la posición Z en el grid
        bool passed = true;     // Flag
    };


Podemos iterar sobre dicho array para obtener el camino deseado.

    ...
    path = eye:getGrid3D():makeTravelCubesGrid() -- Obtenemos un array de CubeGrid3D
    -- Iteramos sobre el array path y pintamos los índices de cada CubeGrid3D
    for i, cube in ipairs(path) do
        -- Imprimimos las coordenadas de cada CubeGrid3D
        print("Cube " .. i .. ": X = " .. cube.posX .. ", Y = " .. cube.posY .. ", Z = " .. cube.posZ)
    end
    ...

========================================================================================================

### Ejemplos completos con código LUA

========================================================================================================

https://github.com/rzeronte/brakeza3d/blob/master/doc/examples-lua-code.md